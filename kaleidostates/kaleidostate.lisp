;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                               kaleidostate.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Copyright (c) 1990 Statistical Computing Laboratory, University of Waterloo;;;;;;;;;  Authors:;;;     R.W. Oldford 1990.;;;;;;;;;----------------------------------------------------------------------------------;;;;;;                       ;;;--------------------------------------------------------------------------;;;;;;  kaleidostates;;;;;;--------------------------------------------------------------------------(defclass kaleidostate ()  ((state-lenses :initform '()                 :accessor state-lenses-of                 :documentation                 "A list of the current state-lenses which give the ~                  current states of this kaleidostate.")   (constraints :initform '()                :accessor constraints-of                :documentation                "A list of the current constraints in which this kaleidostate ~                 participates."))  (:documentation "An object whose contents (as defined by a state-lens) ~                   can be constrained via any constraint object. ~                   Kaleidostates can have as many kinds of state constrained ~                   as it has state-lenses. ~                   Kaleido-states  can participate in arbitrarily many constraints."));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  The maker;;;(defun make-kaleidostate       (&rest keyword-pairs &key (type NIL) &allow-other-keys)  (if type    (apply #'make-instance type           :allow-other-keys T keyword-pairs)    (apply #'make-instance 'kaleidostate           :allow-other-keys T keyword-pairs)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Basic generic functions for kaleidostates;;;;;;(defgeneric same-state-p  (state1 state2);  (:documentation "Test whether two states are to be taken as identical.")  )(defgeneric state-type  (kaleidostate interrogator);  (:documentation;    "Determine the state-type that the interrogator will ~;     be referring to when examining the state of ~;     the kaleidostate.  Returns NIL if the state-type ~;     is indeterminate.")  )(defgeneric has-state-p  (kaleidostate &key as-seen-by state-lens state-type);  (:documentation;    "Test whether the kaleidostate has a state ~;     with respect to the given keywords. ~;     If non-NIL, one of state-lens, state-type, or as-seen-by ~;     is used (in that order) to determine the result.  ~;     If both state-lens and state-type are non-NIL, they ~;     must have the same-state-type-p or an error results.")  )(defgeneric state-of  (kaleidostate &key as-seen-by state-lens state-type);  (:documentation ;    "Returns the state of the kaleidostate ~;     with respect to the given keywords. ~;     If non-NIL, one of state-lens, state-type, or as-seen-by ~;     is used (in that order) to determine the result.  ~;     If both state-lens and state-type are non-NIL, they ~;     must have the same-state-type-p or an error results."))(defgeneric update-state  (kaleidostate update-info informant   &rest keyword-pairs   &key state-lens state-type   &allow-other-keys);  (:documentation;    "Sets the state of (as defined by the state-type or informant) ~;     the kaleidostate to the update-info.  ~%~;     If non-NIL, state-lens or state-type is used to determine the state.  ~;     If both state-lens and state-type are non-NIL, they must agree on ~;     state-type.  ~;     Other keys will be passed to make-state-lens if necessary.")  )(defgeneric lose-state  (kaleidostate informant   &rest keyword-pairs   &key state-lens state-type   &allow-other-keys);  (:documentation;    "Sets the kaleidostate to be stateless~;     (as defined by the informant). ~%~;     If non-NIL, state-lens or state-type is used to determine the state-lens.  ~;     Other keys will be passed to make-state-lens if necessary.")  )(defgeneric legal-pass-p  (kaleidostate informant state-type);  (:documentation ;    "Test whether a pass of information of type given by state-type ~;     is allowed from the informant to the kaleidostate.~%~;     ** Note ** :~%~;     This is the sole means of controlling ~;     the direction of flow of information in the constraint network.")  )(defgeneric informant-of  (kaleidostate &key state-type);  (:documentation ;    "Find the informant of this state-type of the kaleidostate.")  )(defgeneric set-informant  (kaleidostate informant &key state-lens state-type);  (:documentation;    "Sets the informant for this state-type ~;     of the kaleidostate. ~%~;     If non-NIL, state-lens or state-type is used to determine the state.  ~;     If both state-lens and state-type are non-NIL, only ~;     state-lens will be used.")  )(defgeneric constraint-of-p  (kaleidostate constraint);  (:documentation;    "This predicate tests whether the kaleidostate is directly constrained by ~;     the given constraint."))(defgeneric add-constraint  (kaleidostate constraint);  (:documentation;    "Adds the constraint to the collection of constraints directly ~;     involving the kaleidostate.")  )(defgeneric remove-constraint  (kaleidostate constraint);  (:documentation;    "Removes the constraint from the collection of constraints directly ~;     involving the kaleidostate.")  );;;--------------------------------------------------------------------------;;;;;;  state-lenses;;;;;;  The state of the kaleidostate is different depending on;;;  the type of state that is of interest and perhaps on who's doing;;;  the viewing.;;;  A state lens provides the means to view and alter the;;;  appropriate state of the kaleidostate.;;;;;;;;;--------------------------------------------------------------------------(defclass state-lens  ()  ((state-type     :reader state-type-of     :initform 'simple-state     :initarg :state-type     :documentation "The type of state seen through this lens. ~                     State-type must be non-NIL.")   (update-info     :accessor update-info-of     :initform 'no-state     :initarg :update-info     :documentation "The last information passed to this lens to update ~                     the state.")   (setter     :reader setter-of     :initarg :setter     :initform NIL     :documentation "The identity of the last object to set the state ~                     through this lens. ~                     Setter must be non-NIL.")   (update-function     :accessor update-function-of     :initform #'(lambda (kaleidostate lens update-info)                   (declare (ignore kaleidostate lens update-info)))     :initarg :update-function     :documentation "Function to invoke when the state is updated.")   (get-function     :accessor get-function-of     :initform #'(lambda (kaleidostate lens)                   (declare (ignore kaleidostate))                   (update-info-of lens))     :initarg :get-function     :documentation "Function to invoke when the state is accessed.")   (act-on-update-function     :accessor act-on-update-function-of     :initform #'(lambda (kaleidostate lens informant)                   (declare (ignore kaleidostate lens informant)))     :initarg :act-on-update-function     :documentation     "Function to invoke after the state has been updated. ~      Called when the kaleidostate's state is set via update-state.")   )  (:documentation "A lens through which a kaleidostate is viewed ~                   to interact with its perceived state.")  );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Slot writer methods;;;(defmethod (setf state-type-of)  (new-value (self state-lens))  (if new-value    (setf (slot-value self 'state-type) new-value)    (error "State-type of the state-lens ~s must be non-NIL!"            self)))(defmethod (setf setter-of)  (new-value (self state-lens))  (if new-value    (setf (slot-value self 'setter) new-value)    (error "Setter of the state-lens ~s must be non-NIL!"            self)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Make sure initialization;;;  doesn't permit illegal slot;;;  values.(defmethod initialize-instance :after  ((self state-lens) &rest initargs)  (when (null (state-type-of self))    (setf (state-type-of self) 'simple-state)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  The maker;;;(defun make-state-lens (&rest keyword-pairs                        &key (type NIL)                        &allow-other-keys)  (if type    (apply #'make-instance type           :allow-other-keys T keyword-pairs)    (apply #'make-instance 'state-lens           :allow-other-keys T keyword-pairs)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Same state-type checking;;; (defgeneric same-state-type-p  (state-lens-1 state-lens-2);  (:documentation;   "Tests whether the two arguments have the same state-type."  )  (defmethod same-state-type-p  ((s-l-1 state-lens) (s-l-2 state-lens))  (equal (state-type-of s-l-1) (state-type-of s-l-2)))(defmethod same-state-type-p  ((s-l-1 state-lens) state-type)  (equal (state-type-of s-l-1) state-type))(defmethod same-state-type-p  (state-type (s-l-2 state-lens))  (equal state-type (state-type-of s-l-2)))(defmethod same-state-type-p  (state-type-1 state-type-2)  (equal state-type-1 state-type-2));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Same setter checking;;; (defgeneric same-setter-p  (state-lens-1 state-lens-2);  (:documentation;   "Tests whether the two arguments have the same setter.")  )(defmethod same-setter-p  ((s-l-1 state-lens) (s-l-2 state-lens))  (equal (setter-of s-l-1) (setter-of s-l-2)))(defmethod same-setter-p  ((s-l-1 state-lens) setter)  (equal (setter-of s-l-1) setter))(defmethod same-setter-p  (setter (s-l-2 state-lens))  (equal setter (setter-of s-l-2)))(defmethod same-setter-p  (setter-1 setter-2)  (equal setter-1 setter-2));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Same update-info checking;;; (defgeneric same-update-info-p  (state-lens-1 state-lens-2);  (:documentation;   "Tests whether the two arguments have the same update-info.")  )(defmethod same-update-info-p  ((s-l-1 state-lens) (s-l-2 state-lens))  (equal (update-info-of s-l-1) (update-info-of s-l-2)))(defmethod same-update-info-p  ((s-l-1 state-lens) update-info)  (equal (update-info-of s-l-1) update-info))(defmethod same-update-info-p  (update-info (s-l-2 state-lens))  (equal update-info (update-info-of s-l-2)))(defmethod same-update-info-p  (update-info-1 update-info-2)  (equal update-info-1 update-info-2));;;---------------------------------------------------------------------------;;;;;;  Functions which allow interaction with the state-lenses of the;;;  given kaleidostate.;;;;;;---------------------------------------------------------------------------;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  A general function for finding;;;  a state-lens of specified;;;  properties or just testing;;;  whether a given state-lens;;;  is present on the kaleidostate;;;  (using item).;;; (defun find-state-lens  (kaleidostate &key state-type update-info setter key test item)  "Finds a state-lens of the kaleidostate. ~   The state-lens is determined in one of three ways: ~%~   1. By the values of the keywords state-type, ~      update-info, and setter.  The state-lens must match on ~      all values supplied using same-state-type-p, same-update-info-p, ~      and/or same-setter-p. ~%~   2. By the key words item, key and test.  ~      If item is supplied, then test is a predicate function ~      of two arguments - the item and each state-lens to ~      be tested (default is as in CL sequence remove) - and key, if ~      not NIL, should be a function of one argument that will extract ~      from each state-lens of the kaleidostate the part to be tested ~      in place of the whole state-lens.  ~      If item is not supplied, then test *must* be supplied.  ~      Test must be a predicate function of a single argument which ~      is applied to each state-lens.  The parameter key is as before.~%~   3. By looking for a lens of state-type simple-state only if ~      *all* keyword arguments are NIL. ~%~   It is an error to use keywords from both of the above groups."    ;; Error check  (when    (and (or state-type update-info setter)         (or test key item))    (error "Incompatible keyword arguments given to ~             find-state-lens.  ~%~             Can't have one or more of (state-type update-info setter) ~             and one or more of (item test key) at the same time."))  (let ((s-ls (state-lenses-of kaleidostate)))        (if (or state-type update-info setter)      ;; then first method is used      (cond       ((and state-type update-info setter)        (find-if            #'(lambda (s-l)                (and (same-state-type-p state-type (state-type-of s-l))                     (same-setter-p setter (setter-of s-l))                     (same-update-info-p update-info (update-info-of s-l))))            s-ls))       ((and state-type setter)        (find-if            #'(lambda (s-l)                (and (same-state-type-p state-type (state-type-of s-l))                     (same-setter-p setter-of (setter-of s-l))))            s-ls))       ((and state-type update-info)        (find-if            #'(lambda (s-l)                (and (same-state-type-p state-type (state-type-of s-l))                     (same-update-info-p update-info (update-info-of s-l))))            s-ls))       (state-type        (find-if            #'(lambda (s-l)                (same-state-type-p state-type (state-type-of s-l)))            s-ls))       ((and update-info setter)        (find-if            #'(lambda (s-l)                (and (same-setter-p setter (setter-of s-l))                     (same-update-info-p update-info (update-info-of s-l))))            s-ls))       (setter        (find-if            #'(lambda (s-l)                (same-setter-p setter (setter-of s-l)))            s-ls))       (update-info        (find-if            #'(lambda (s-l)                (same-update-info-p update-info (update-info-of s-l)))            s-ls))       )      ;; else second method      (if item        ;; then use it in comparison        (cond         ((and test key) (find item s-ls :test test :key key))         (test (find item s-ls :test test))         (key (find item s-ls :key key))         (T (find item s-ls)))        ;; else general testing        (cond         ((and test key) (find-if test s-ls :key key))         (test (find-if test s-ls))         (key (error               "Insufficient information to find a state-lens! ~%~                Only key = ~s was supplied."               key))         (T           ;; Otherwise look for a state-lens having state-type 'simple-state          (find-if            #'(lambda (s-l)                (same-state-type-p 'simple-state (state-type-of s-l)))            s-ls))         )        )      )    )  )    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Adding a state-lens to;;;  a kaleidostate;;; (defun add-state-lens  (state-lens kaleidostate)  "Adds the state-lens to those of the kaleidostate ~   and returns the state-lens added ~   (error if a state-lens of the same state-type already exists)."    (if (typep state-lens 'state-lens)    (push state-lens (state-lenses-of kaleidostate))    (error "The object ~s must be a state-lens."            state-lens))  state-lens);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Compute the appropriate;;;  state-lens, creating and;;;  installing one if necessary.;;;(defun compute-state-lens    (kaleidostate      &rest keyword-pairs      &key state-lens state-type as-seen-by      &allow-other-keys)  "Computes the installed state-lens for this kaleidostate ~   given the relevant keywords as input.  ~%~   Returns two values: the computed state-lens, and an already-installed? flag ~   which is T if the state-lens returned was already installed on the ~   kaleidostate and NIL otherwise. ~%~   The state-lens returned is that one installed on the kaleidostate ~   whose state-type is either: ~%~   1. The same-state-type-p as the value of the keyword state-lens. ~%~   2. Or the same-state-type-p as the value of the keyword state-type. ~%~   3. Or the same-state-type-p as the value of ~      (state-type kaleidostate as-seen-by). ~%~   4. simple-state when all keywords are NIL.  ~%~   If none of these returns a state-lens, then a new state-lens is ~   created with make-state-lens and the remaining keyword parameters. ~   The new state-lens is then added to the kaleidostate. ~%~   Note: It is an error if both state-lens and state-type ~         are non-NIL and are not same-state-p."    ;; Error check  (when    (and state-lens         state-type         (not (same-state-type-p state-lens state-type)))    (error "Contradictory keyword arguments given to ~             compute-state-lens.  ~%~             State-type = ~s, ~%~             but (state-type-of state-lens) = ~s! "            state-type            (state-type-of state-lens)))    ;; Compute the lens.  (let* ((s-t (or (and state-lens (state-type-of state-lens))                  state-type                  (state-type kaleidostate as-seen-by)))         (existing-s-l           (find-state-lens kaleidostate :state-type s-t)))    (cond      (existing-s-l      ;; then return existing one      (setf state-lens existing-s-l)      (setf existing-s-l T))     (T      ;; else use supplied one or construct new one.      (when (null state-lens)        (setf state-lens              (apply #'make-state-lens :allow-other-keys T                     :setter as-seen-by                     ;; N.B. update-info is guaranteed useless                     :update-info 'no-state                     keyword-pairs))        )      ;; Either way add it      (add-state-lens state-lens kaleidostate)      )     )    ;;  And return the values    (values state-lens existing-s-l)    )  );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Removing a state-lens from;;;  a kaleidostate;;; (defun remove-state-lens  (kaleidostate      &key state-type update-info setter key test item)  "Removes a state-lens from those of the kaleidostate. ~   The state-lens is determined in one of three ways: ~%~   1. By the values of the keywords state-type, ~      update-info, and setter.  The state-lens removed must match on ~      all values supplied using same-state-type-p, same-update-info-p, ~      and/or same-setter-p. ~%~   2. By the key words item, key and test.  ~      If item is supplied, then test is a predicate function ~      of two arguments - the item and each state-lens to ~      be tested (default is as in CL sequence remove) - and key, if ~      not NIL, should be a function of one argument that will extract ~      from each state-lens of the kaleidostate the part to be tested ~      in place of the whole state-lens.  ~      If item is not supplied, then test *must* be supplied.  ~      Test must be a predicate function of a single argument which ~      is applied to each state-lens.  The parameter key is as before.~%~   3. If *all* keywords are NIL, then the state-lens whose state-type is ~      simple-state is removed.~%~   It is an error to use keywords from both of the above groups."    ;; Error check  (when    (and (or state-type update-info setter)         (or test key item))    (error "Incompatible keyword arguments given to ~             remove-state-lens.  ~%~             Can't have one or more of (state-type update-info setter) ~             and one or more of (item test key) at the same time."))          (let ((s-ls (state-lenses-of kaleidostate)))    (if (or state-type update-info setter)      (cond       ((and state-type update-info setter)        (setf (state-lenses-of kaleidostate)              (remove-if                    #'(lambda (s-l)                        (and (same-state-type-p (state-type-of s-l)                                                state-type)                             (same-setter-p (setter-of s-l)                                            setter)                             (same-update-info-p s-l update-info)))                    s-ls)))       ((and state-type setter)        (setf (state-lenses-of kaleidostate)              (remove-if                     #'(lambda (s-l)                        (and (same-state-type-p (state-type-of s-l)                                                state-type)                             (same-setter-p (setter-of s-l)                                            setter)))                    s-ls)))       ((and state-type update-info)        (setf (state-lenses-of kaleidostate)              (remove-if                     #'(lambda (s-l)                        (and (same-state-type-p (state-type-of s-l)                                                state-type)                             (same-update-info-p s-l update-info)))                    s-ls)))       (state-type        (setf (state-lenses-of kaleidostate)              (remove-if                     #'(lambda (s-l)                        (same-state-type-p (state-type-of s-l)                                           state-type))                    s-ls)))       ((and update-info setter)        (setf (state-lenses-of kaleidostate)              (remove-if                     #'(lambda (s-l)                        (and (same-setter-p (setter-of s-l)                                            setter)                             (same-update-info-p s-l update-info)))                    s-ls)))       (setter        (setf (state-lenses-of kaleidostate)              (remove-if                    #'(lambda (s-l)                        (same-setter-p (setter-of s-l) setter))                    s-ls)))       (update-info        (setf (state-lenses-of kaleidostate)              (remove-if                    #'(lambda (s-l)                        (same-update-info-p s-l update-info))                    s-ls))))      (if item        ;; then use it, possibly to compare with others        (cond         ((and test key)          (setf (state-lenses-of kaleidostate)                (remove item s-ls :test test :key key)))         (test          (setf (state-lenses-of kaleidostate)                (remove item s-ls :test test)))         (key          (setf (state-lenses-of kaleidostate)                (remove item s-ls :key key)))         (T          (setf (state-lenses-of kaleidostate)                (remove item s-ls))))        ;; else general testing        (cond         ((and test key)          (setf (state-lenses-of kaleidostate)                (remove-if test s-ls :key key)))         (test          (setf (state-lenses-of kaleidostate)                (remove-if test s-ls)))         (key          (error           "Insufficient information to determine removal! ~%~            Only key = ~s was supplied."           key))         (T          ;; Try removing the simple-state lens          (setf (state-lenses-of kaleidostate)                (remove-if                     #'(lambda (s-l)                        (same-state-type-p (state-type-of s-l)                                           'simple-state)))))         )        )      )    )  )