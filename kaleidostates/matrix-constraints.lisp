(defclass matrix-multiplier (matrix-operation-constraint)  ((left-factor-matrix    :initarg :left-factor-matrix    :accessor left-factor-matrix-of     :initform NIL)   (right-factor-matrix     :initarg :right-factor-matrix     :accessor right-factor-matrix-of     :initform NIL)   (product-matrix     :initarg :product-matrix     :accessor product-matrix-of     :initform NIL)))(defmethod process-update-info ((m-m matrix-multiplier)  informant)  (let    ((l-f-m (left-factor-matrix-of m-m))     (r-f-m (right-factor-matrix-of m-m))     (p-m (product-matrix-of m-m))     l-s-t     r-s-t     p-s-t)    (when (not (or (null l-f-m) (null r-f-m) (null p-m)))      (<- l-s-t (state-type l-f-m m-m))      (<- r-s-t (state-type r-f-m m-m))      (<- p-s-t (state-type p-m m-m))      (cond       ((eq informant l-f-m)        (cond         ((and (has-state-p r-f-m :state-type r-s-t)               (legal-pass-p p-m m-m p-s-t))          (update-state p-m (.* (state-of l-f-m :as-seen-by m-m)                                (state-of r-f-m :as-seen-by m-m))                        m-m :state-type p-s-t))         ((and (has-state-p p-m :state-type p-s-t)               (is-invertible (state-of l-f-m :as-seen-by m-m))               (legal-pass-p r-f-m m-m r-s-t))          (update-state r-f-m (.* (inverse (state-of l-f-m :as-seen-by m-m))                                  (state-of p-m :as-seen-by m-m))                        m-m :state-type r-s-t))))       ((eq informant r-f-m)        (cond         ((and (has-state-p l-f-m :state-type l-s-t)               (legal-pass-p p-m m-m p-s-t))          (update-state p-m (.* (state-of l-f-m :as-seen-by m-m)                                (state-of r-f-m :as-seen-by m-m))                        m-m :state-type p-s-t))         ((and (has-state-p p-m :state-type p-s-t)               (is-invertible (state-of r-f-m :as-seen-by m-m))               (legal-pass-p l-f-m m-m l-s-t))          (update-state l-f-m (.* (state-of p-m :as-seen-by m-m)                                  (inverse (state-of r-f-m :as-seen-by m-m)))                        m-m :state-type r-s-t))))       ((eq informant p-m)        (cond         ((and (has-state-p l-f-m :state-type l-s-t)               (is-invertible (state-of l-f-m :as-seen-by m-m))               (legal-pass-p r-f-m m-m r-s-t))          (update-state r-f-m (.* (inverse (state-of l-f-m :as-seen-by m-m))                                  (state-of p-m :as-seen-by m-m))                        m-m :state-type r-s-t))         ((and (has-state-p r-f-m :state-type r-s-t)               (is-invertible (state-of r-f-m :as-seen-by m-m))               (legal-pass-p l-f-m m-m l-s-t))          (update-state l-f-m (.* (state-of p-m :as-seen-by m-m)                                  (inverse (state-of r-f-m :as-seen-by m-m)))                        m-m :state-type r-s-t))))       )      )    )  )(defmethod matrix-multiplier  ((left kaleidostate) (right kaleidostate) (product kaleidostate)   &rest keyword-pairs &key state-types &allow-other-keys)  (let ((result         (apply #'make-constraint :type 'matrix-multiplier            :allow-other-keys T keyword-pairs))        (l-state NIL) (r-state NIL) (p-state NIL))    (if state-types      (cond       ((listp state-types)        (setf l-state (first state-types))        (setf r-state (second state-types))        (setf p-state (third state-types)))       (T        (setf l-state state-types)        (setf r-state state-types)        (setf p-state state-types))))    (constrain left result :accessor 'left-factor-matrix-of :state-type l-state)    (constrain right result :accessor 'right-factor-matrix-of :state-type r-state)    (constrain product result :accessor 'product-matrix-of :state-type p-state)    result))(defun is-invertible (X)  (and (is-square X) (is-full-rank X)))(defun is-square (X)  (= (nrows X) (ncols X)))(defun is-full-rank (X)  (= (nrows X) (rank-of X)))