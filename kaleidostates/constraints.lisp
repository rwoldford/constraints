;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                               constraints.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Copyright (c) 1990 Statistical Computing Laboratory, University of Waterloo;;;;;;;;;  Authors:;;;     R.W. Oldford 1990.;;;;;;;;;----------------------------------------------------------------------------------;;;;;;                  ;;;------------------------------------------------------------------------------;;;;;;  General constraints;;;;;;------------------------------------------------------------------------------(defclass constraint ()  ((participants    :initarg :participants    :initform '()    :accessor participants-of    :documentation    "A list of the objects which participate in this constraint.")   (participant-state-types    :initarg :participant-state-types    :initform '()    :accessor participant-state-types-of    :documentation    "A list of the state-types of all participants arranged in the same ~     order as the participants in the participants-of this constraint."))  (:documentation   "An object which can constrain a named state-type of each of one or more ~    kaleidostate.  N.B. Though many different state-types may be being ~    constrained by a single constraint, only one state-type is allowed ~    for each participant in a constraint.")  );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  The maker;;;(defun make-constraint       (&rest keyword-pairs &key (type NIL) &allow-other-keys)  (if type    (apply #'make-instance type           :allow-other-keys T keyword-pairs)    (apply #'make-instance 'constraint           :allow-other-keys T keyword-pairs)));;;------------------------------------------------------------------------------;;;;;; Basic generic functions for constraints.;;;;;;------------------------------------------------------------------------------(defgeneric process-update-info  (constraint informant);  (:documentation;   "Have the constraint process the updated information from informant.")  )(defgeneric process-lost-state  (constraint informant);  (:documentation;   "Have the constraint process the fact that informant has lost ~;    its state.")  )(defgeneric inform-about-state  (constraint informant);  (:documentation;   "Inform the constraint that informant has state (possibly new).")   )(defgeneric inform-about-no-state  (constraint informant);  (:documentation;   "Inform the constraint that informant has lost its state.")   );;;------------------------------------------------------------------------------;;;;;; constraining kaleidostates and constraints;;;;;;------------------------------------------------------------------------------(defgeneric constrain  (kaleidostate constraint   &key state-type accessor reader writer with-setf?);  (:documentation;   "Have the kaleidostate participate in the constraint.~;    State-type identifies the state-type of the kaleidostate that ~;    is to be constrained (default state-type is simple-state).  ~;    If non-NIL, accessor, reader, and writer are the names of functions ~;    that access, read, and write the ~;    slot on the constraint where the kaleidostate is to appear.  ~;    If with-setf? is non-NIL (the default), then the (setf writer) ~;    setf method is used.  Otherwise writer alone is funcalled with ~;    arguments constraint and kaleidostate to do the setting.")   )(defgeneric unconstrain  (kaleidostate constraint   &key state-type accessor reader writer with-setf?);  (:documentation;   "Have the kaleidostate stop participating in the constraint.~;    State-type identifies the state-type of the kaleidostate that ~;    is to be constrained (default state-type is simple-state).  ~;    If non-NIL, accessor, reader, and writer are the names of functions ~;    that access, read, and write the ~;    slot on the constraint where the kaleidostate is supposed to be.  ~;    slot on the constraint where the kaleidostate is to appear.  ~;    If with-setf? is non-NIL (the default), then the (setf writer) ~;    setf method is used.  Otherwise writer alone is funcalled with ~;    arguments constraint and NIL to do the setting.")    )(defgeneric remove-participant  (constraint kaleidostate   &key state-type accessor reader writer with-setf?);  (:documentation;   "Remove the kaleidostate from the constraint.  ~;    State-type identifies the state-type of the kaleidostate that ~;    is to be constrained (default state-type is simple-state).  ~;    If non-NIL, accessor, reader, and writer are the names of functions ~;    that access, read, and write the ~;    slot on the constraint where the kaleidostate is supposed to be.  ~;    If with-setf? is non-NIL (the default), then the (setf writer) ~;    setf method is used.  Otherwise writer alone is funcalled with ~;    arguments constraint and NIL to do the setting.")    )(defgeneric add-participant  (constraint kaleidostate   &key state-type accessor reader writer with-setf?);  (:documentation;   "Add the kaleidostate to the constraint.  ~;    State-type identifies the state-type of the kaleidostate that ~;    is to be constrained (default state-type is simple-state).  ~;    If non-NIL, accessor, reader, and writer are the names of functions ~;    that access, read, and write the ~;    slot on the constraint where the kaleidostate is to appear.  ~ ;    If with-setf? is non-NIL (the default), then the (setf writer) ~;    setf method is used.  Otherwise writer alone is funcalled with ~;    arguments constraint and kaleidostate to do the setting.")    );;;------------------------------------------------------------------------------;;;;;; defmethods for general constraints;;;;;;------------------------------------------------------------------------------;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  First, the method to compute the;;;  state-type for a given constraint.;;;(defmethod state-type  ((ks kaleidostate) (c constraint))  (loop      for p in (participants-of c)      as s in (participant-state-types-of c)      when (eq p ks)      return s)  );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  processing the update information;;;  will be unique to each class of;;;  constraint.;;;  Specialization is required.(defmethod process-update-info  ((c constraint) informant)  (missing-method 'process-update-info c informant))#|(defmethod process-update-info :around  ((c constraint) informant)  ;(loop  ;  for p in (participants-of c)  ;  unless (eq p informant)  ;  when (legal-pass-p p c (state-type p c))  ;  do (lose-state p c :state-type (state-type p c)))  (call-next-method))|#(defmethod process-lost-state  ((c constraint) informant)  (loop    for p in (participants-of c)    as s-t in (participant-state-types-of c)    unless (eq informant p)    do (lose-state p c :state-type s-t)))(defmethod inform-about-state  ((c constraint) informant)  (when (has-state-p informant :as-seen-by c)    (process-update-info c informant)))(defmethod inform-about-no-state  ((c constraint) informant)  (when (not (has-state-p informant :as-seen-by c))    (process-lost-state c informant)));;;------------------------------------------------------------------------------;;;;;; defmethods for constraining kaleidostates and constraints;;;;;;------------------------------------------------------------------------------(defmethod constrain  ((ks kaleidostate) (c constraint)   &key state-type accessor reader writer (with-setf? T))  (when (not (constraint-of-p ks c))    (add-constraint ks c)    (add-participant c ks :state-type state-type                     :accessor accessor :writer writer                     :reader reader :with-setf? with-setf?)    (inform-about-state c ks)))(defmethod unconstrain  ((ks kaleidostate) (c constraint)   &key state-type accessor reader writer (with-setf? T))  (when (constraint-of-p ks c)    (remove-constraint ks c)    (remove-participant c ks :state-type state-type                        :accessor accessor :writer writer                        :reader reader :with-setf? with-setf?)    (inform-about-no-state c ks)))(defmethod remove-participant  ((c constraint) (ks kaleidostate)   &key state-type accessor reader writer (with-setf? T))  (setf writer (or writer accessor))  (setf reader (or reader accessor))  ;; fix the slot as requested  (if writer    (labels ((set-value-fn ()                 (if with-setf?                   (eval `(function                           (lambda (k val)                                (setf (,writer k) val))))                   (eval `(function                           (lambda (k val)                                (,writer k val))))))             (set-value! (obj val)                 (funcall (set-value-fn) obj val))             (get-value-fn ()                   (eval `(function                           (lambda (k)                                (,reader k)))))             (get-value! (obj)                 (funcall (get-value-fn) obj)))            (if reader        (let ((current-slot-value (get-value! c)))          (if (and current-slot-value (not (eq ks current-slot-value)))            (error "The object ~s is not found as (~s ~s)!  ~                     No removal was done."                    ks reader c))))      (set-value! c ks)))        ;; update the participants & state-types  (loop    for p in (participants-of c)    as s-t in (participant-state-types-of c)    unless (eq p ks)    collect p into ps    and collect s-t into s-ts    finally    (setf (participants-of c) ps)    (setf (participant-state-types-of c) s-ts))  ;; Finally return the removed kaleidostate  ks)(defmethod add-participant  ((c constraint) (ks kaleidostate)   &key state-type accessor reader writer (with-setf? T))  (setf writer (or writer accessor))  (when (not (find ks (participants-of c)))    (push ks (participants-of c))    (push (or state-type 'simple-state) (participant-state-types-of c)))    (if writer    (labels ((set-value-fn ()                 (if with-setf?                   (eval `(function                           (lambda (k val)                                (setf (,writer k) val))))                   (eval `(function                           (lambda (k val)                                (,writer k val))))))             (set-value! (obj value) (funcall (set-value-fn) obj value)))      (set-value! c ks)))  ;; Finally return the added kaleidostate  ks)