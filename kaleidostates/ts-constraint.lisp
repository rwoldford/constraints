(defmethod process-update-info ((tsc time-series-constraint) informant)  (let* ((ds-ks (dataset-ks-of tsc))         (ds (state-of ds-ks :as-seen-by tsc))         (new-value (state-of informant :as-seen-by tsc))         new-dataset)    (if (eq ds 'no-state)      (<- new-dataset (list (list 0 new-value)))      (<- new-dataset (reverse (cons (list (length ds) new-value)                                     (reverse ds))))      )    (update-state ds-ks new-dataset tsc :state-type (state-type ds-ks tsc))    )  )(defmethod tsc ((ks1 kaleidostate) (ks2 kaleidostate) &rest keyword-pairs                &key (state-types (list 'simple-state 'simple-state)) &allow-other-keys)  (let ((result (apply #'make-constraint :type 'time-series-constraint                       :allow-other-keys T keyword-pairs)))    (constrain ks1 result :accessor 'input-ks-of :state-type (first state-types))    (constrain ks2 result :accessor 'dataset-ks-of :state-type (second state-types))    result))