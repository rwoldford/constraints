;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                               kaleidostate-methods.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Copyright (c) 1990 Statistical Computing Laboratory, University of Waterloo;;;;;;;;;  Authors:;;;     R.W. Oldford 1990.;;;;;;;;;----------------------------------------------------------------------------------;;;;;;                       ;;;-------------------------------------------------------------------------;;;;;;  Top-level methods for kaleidostates.;;;;;;-------------------------------------------------------------------------(defmethod same-state-p (state1 state2)  (equal state1 state2))(defmethod same-state-p ((state1 number) (state2 number))  (= state1 state2));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  Include state-lenses as a possibility.;;;(defmethod same-state-p  ((state1 state-lens) (state2 state-lens))    (let ((ui-1 (update-info-of state1))        (ui-2 (update-info-of state2)))    (if (and (typep ui-1 'state-lens)             (typep ui-2 'state-lens))      (eq ui-1 ui-2)      (same-state-p ui-1 ui-2))))(defmethod state-type :around  ((ks kaleidostate) interrogator)  (let ((s-t (call-next-method)))    (if (null s-t)      ;; then see if interrogator has used a state-lens on ks      (let ((s-l (find-state-lens ks :setter interrogator)))        (if s-l          (state-type-of s-l)          'simple-state))            ;; else      s-t)))(defmethod state-type  ((ks kaleidostate) interrogator)  (declare (ignore ks interrogator))  NIL)(defmethod has-state-p :around  (kaleidostate &key as-seen-by state-lens state-type)    (if (and state-lens           state-type           (not (same-state-type-p state-lens state-type)))    (error "Contradictory information on state-type! ~%~             State-type = ~s, ~             but (state-type-of state-lens) = ~s."            state-type            (state-type-of state-lens))    (call-next-method)))(defmethod has-state-p  ((ks kaleidostate) &key as-seen-by state-lens state-type)  (if (null state-type)    (setf state-type          (or (and state-lens (state-of state-lens))              (state-type ks as-seen-by))))  (setf state-lens (find-state-lens ks :state-type state-type))  (if state-lens    (not (eq (update-info-of state-lens) 'no-state))    NIL)  )(defmethod state-of :around  ((ks kaleidostate) &key as-seen-by state-lens state-type)    (if (and state-lens           state-type           (not (same-state-type-p state-lens state-type)))    (error "Contradictory information on state-type! ~%~             State-type = ~s, ~             but (state-type-of state-lens) = ~s."            state-type            (state-type-of state-lens))    (call-next-method)))(defmethod state-of  ((ks kaleidostate) &key as-seen-by state-lens state-type)    (if (null state-type)    (setf state-type          (or (and state-lens (state-of state-lens))              (state-type ks as-seen-by))))  (setf state-lens (find-state-lens ks :state-type state-type))    (if (or (null state-lens)          (eq (update-info-of state-lens) 'no-state))    'no-state    (let ((get-fn (get-function-of state-lens)))      (if (functionp get-fn)        (funcall get-fn ks state-lens)        ;; else default state is whatever is on the update-info.        (update-info-of state-lens)))))(defmethod update-state :around  ((ks kaleidostate) update-info informant   &rest keyword-pairs   &key (state-lens NIL) (state-type NIL)   &allow-other-keys)  ;; Error check on update info  (if (eq update-info 'no-state)    (apply #'lose-state ks update-info informant keyword-pairs)    (call-next-method)))(defmethod update-state                                  ;This method defines  ((ks kaleidostate) update-info informant               ;the protocol for all   &rest keyword-pairs                                   ;kaleidostates.   &key (state-lens NIL) (state-type NIL)   &allow-other-keys)  ;; get the state-lens  (let (already-existed?)    (multiple-value-setq      (state-lens already-existed?)      (apply #'compute-state-lens ks              :state-lens state-lens              :state-type state-type              :as-seen-by informant              :allow-other-keys T              keyword-pairs));  Error checking#|    (cerror "Just continue. ~%"            "Relevant values are: ~%~%~             Kaleidostate = ~s~%~             State-lens = ~s with ~%~             state-type = ~s, ~%~             old update-info = ~s ~%~             new update-info = ~s ~%~             old setter = ~s.~%~             new informant = ~s.~%"            ks            state-lens            (state-type-of state-lens)            (update-info-of state-lens)            update-info            (setter-of state-lens)           ; NIL            informant)|#        (unless (same-update-info-p state-lens update-info)      ;; We want to try an update.            (setf state-type (state-type-of state-lens))      (if        (and already-existed? (has-state-p ks :state-type state-type))        ;; then check whether the informant is legal        ;; N.B. any informant can legally update a thing of no state.        (if (not (legal-pass-p ks informant state-type))          ;; then no update is allowed          (error             "The informant: ~s is not permitted to change state ~%~              of the type: ~s on ~s"             informant state-type ks))        ;; Otherwise carry on!        )      ;; Now, do the update.            ;; First change the setter of the lens.      (setf (setter-of state-lens) informant)            ;; Now use the update information to change the state      ;; * * N.B. * *      ;; Old update info is still on the lens at      ;; this point.  This means both old and new update-info      ;; could be used by the update-fn.      (let ((update-fn (update-function-of state-lens)))        (if (functionp update-fn)          (funcall update-fn ks state-lens update-info)))            ;; Update the update info.      (setf (update-info-of state-lens) update-info)      ;; Perform action after update if desired            (let ((action-fn (act-on-update-function-of state-lens)))        (if (functionp action-fn)          (funcall action-fn ks state-lens informant)))              ;; Inform others of update.      ;; Note that neither state-lens nor state-type is passed on.      ;; Instead, the state must be checked by the constraint.      ;; This allows the constraints to notice changes of state      ;; that were caused as a side-effect of changes in      ;; some other state of the kaleidostate.      (loop for constraint in (constraints-of ks)            unless (eq constraint informant)            do (inform-about-state constraint ks)            )      )    )  update-info)(defmethod lose-state  ((ks kaleidostate) informant   &rest keyword-pairs   &key (state-lens NIL) (state-type NIL)   &allow-other-keys)    ;; get the state-lens  (setf state-lens         (apply #'compute-state-lens ks :state-lens state-lens                :state-type state-type :as-seen-by informant                :allow-other-keys T                keyword-pairs))#|    (cerror "Just continue. ~%"            "Relevant values are: ~%~%~             Kaleidostate = ~s ~%~             State-lens = ~s with ~%~             state-type = ~s, ~%~             old update-info = ~s ~%~             new update-info = ~s ~%~             old setter = ~s.~%~             new informant = ~s.~%"            ks            state-lens            (state-type-of state-lens)            (update-info-of state-lens)            'no-state            (setter-of state-lens)            informant)|#  ;; Now that the state-lens is in hand we can proceed  (when (not (eq (update-info-of state-lens) 'no-state))    (setf state-type (state-type-of state-lens))    (if (legal-pass-p ks informant state-type)      (progn        (setf (update-info-of state-lens) 'no-state)        (loop for constraint in (constraints-of ks)            unless (eq informant constraint)            do (inform-about-no-state constraint ks))        'no-state)      )    )  )(defmethod legal-pass-p  :around  ((ks kaleidostate) interrogator state-type)  (cond    ((null state-type) (error "State-type cannot be NIL!"))   ((null interrogator) NIL)   (T (call-next-method))))(defmethod legal-pass-p  ((ks kaleidostate) interrogator state-type)  (let ((setter (informant-of ks :state-type state-type)))    (or (null setter)        (eq interrogator setter))))  (defmethod informant-of  ((ks kaleidostate) &key state-type)  (let ((state-lens (find-state-lens ks :state-type state-type)))    (if state-lens      (setter-of state-lens)      NIL)))(defmethod set-informant  ((ks kaleidostate) informant &key (state-lens NIL) (state-type NIL))    (setf state-lens        (compute-state-lens ks :state-len state-lens                               :state-type state-type                               :as-seen-by informant))  (setf (setter-of state-lens) informant)  )(defmethod constraint-of-p  ((self kaleidostate) constraint)  (find constraint (constraints-of self)))(defmethod add-constraint  ((self kaleidostate) constraint)  (setf (constraints-of self)        (cons constraint (constraints-of self))))(defmethod remove-constraint  ((kaleidostate kaleidostate) constraint)  (setf (constraints-of kaleidostate)        (remove constraint (constraints-of kaleidostate))))