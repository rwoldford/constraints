;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                               arithmetic-constraints.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Copyright (c) 1990 Statistical Computing Laboratory, University of Waterloo;;;;;;;;;  Authors:;;;     R.W. Oldford 1990.;;;;;;;;;-----------------------------------------------------------------------------;;;;;;  Arithmetic constraints;;;;;;-----------------------------------------------------------------------------(defclass arithmetic-constraint (constraint)  ())(defmethod remove-participant :around  ((a-c arithmetic-constraint) (ks kaleidostate)   &key state-type accessor reader writer (with-setf? T))  (let ((result (call-next-method)))    (inform-about-no-state a-c ks)    result));;;------------------------------------------------------------------------------;;;;;; The adder constraint;;;;;;------------------------------------------------------------------------------(defclass adder (arithmetic-constraint)  ((left-term :initarg :left-term :accessor left-term-of :initform '())   (right-term :initarg :right-term :accessor right-term-of :initform '())   (sum :initarg :sum :accessor sum-of :initform NIL)))(defmethod process-update-info ((a adder) informant)  (with-accessors    ((x left-term-of)     (y right-term-of)     (x+y sum-of))    a    (when (not (or (null x) (null y) (null x+y)))      (let        ((x-s-t (state-type x a))         (y-s-t (state-type y a))         (x+y-s-t (state-type x+y a)))        (cond         ((and (has-state-p x :state-type x-s-t)               (has-state-p y :state-type y-s-t)               (legal-pass-p x+y a x+y-s-t))          (update-state x+y (+ (state-of x :state-type x-s-t)                               (state-of y :state-type y-s-t))                        a :state-type x+y-s-t))         ((and (has-state-p x :state-type x-s-t)               (has-state-p x+y :state-type x+y-s-t)               (legal-pass-p y a y-s-t))          (update-state y (- (state-of x+y :state-type x+y-s-t)                             (state-of x :state-type x-s-t))                        a :state-type y-s-t))         ((and (has-state-p y :state-type y-s-t)               (has-state-p x+y :state-type x+y-s-t)               (legal-pass-p x a x-s-t))          (update-state  x (- (state-of x+y :state-type x+y-s-t)                            (state-of y :state-type y-s-t))                         a :state-type x-s-t))         )        )      )    )  )(defmethod adder  ((x kaleidostate) (y kaleidostate) (sum  kaleidostate)   &rest keyword-pairs &key state-types &allow-other-keys)  (let ((result         (apply #'make-constraint :type 'adder            :allow-other-keys T keyword-pairs))        (x-state NIL) (y-state NIL) (s-state NIL))    (if state-types      (cond       ((listp state-types)        (setf x-state (first state-types))        (setf y-state (second state-types))        (setf s-state (third state-types)))       (T        (setf x-state state-types)        (setf y-state state-types)        (setf s-state state-types))))    (constrain x result :accessor 'left-term-of :state-type x-state)    (constrain y result :accessor 'right-term-of :state-type y-state)    (constrain sum result :accessor 'sum-of :state-type s-state)    result))    ;;;------------------------------------------------------------------------------;;;;;; The multiplier constraint;;;;;;------------------------------------------------------------------------------(defclass multiplier (arithmetic-constraint)  ((left-term :initarg :left-term :accessor left-term-of :initform NIL)   (right-term :initarg :right-term :accessor right-term-of :initform NIL)   (product :initarg :product :accessor product-of :initform NIL)))(defmethod process-update-info ((m multiplier)  informant)  (with-accessors    ((x left-term-of)     (y right-term-of)     (x*y product-of))    m   (let     ((x-s-t (state-type x m))      (y-s-t (state-type y m))      (x*y-s-t (state-type x*y m)))     (cond      ((and (has-state-p x :state-type x-s-t)            (has-state-p y :state-type y-s-t)            (legal-pass-p x*y m x*y-s-t))       (update-state x*y (* (state-of x :state-type x-s-t)                             (state-of y :state-type y-s-t))                     m :state-type x*y-s-t))      ((and (has-state-p x :state-type x-s-t)            (has-state-p x*y :state-type x*y-s-t)            (legal-pass-p y m y-s-t))       (update-state y (/ (state-of x*y :state-type x*y-s-t)                           (state-of x :state-type x-s-t))                     m :state-type y-s-t))      ((and (has-state-p y :state-type y-s-t)            (has-state-p x*y :state-type x*y-s-t)            (legal-pass-p x m x-s-t))       (update-state x (/ (state-of x*y :state-type x*y-s-t)                           (state-of y :state-type y-s-t))                     m :state-type x-s-t))       )     )   )  )(defmethod multiplier  ((x kaleidostate) (y kaleidostate) (product kaleidostate)   &rest keyword-pairs &key state-types &allow-other-keys)  (let ((result         (apply #'make-constraint :type 'multiplier            :allow-other-keys T keyword-pairs))        (x-state NIL) (y-state NIL) (p-state NIL))    (if state-types      (cond       ((listp state-types)        (setf x-state (first state-types))        (setf y-state (second state-types))        (setf p-state (third state-types)))       (T        (setf x-state state-types)        (setf y-state state-types)        (setf p-state state-types))))    (constrain x result :accessor 'left-term-of :state-type x-state)    (constrain y result :accessor 'right-term-of :state-type y-state)    (constrain product result :accessor 'product-of :state-type p-state)    result));;;-------------------------------------------------------------------------------;;;;;; Defining a constant;;;;;;-------------------------------------------------------------------------------(defclass constant (constraint)  ((fixed-update-info :initarg :fixed-update-info :accessor fixed-update-info-of)))(defmethod process-update-info ((c constant) informant)  ())(defmethod process-lost-state ((c constant) informant)  ())(defmethod constant  ((kaleidostate kaleidostate) fixed-update-info   &rest keyword-pairs &key state-type   &allow-other-keys)  (let    ((result      (apply #'make-constraint :type 'constant             :fixed-update-info fixed-update-info             :allow-other-keys T             keyword-pairs)))    (constrain kaleidostate result :state-type state-type)    (update-state kaleidostate fixed-update-info result :state-type state-type)    result));;;----------------------------------------------------------------------------------;;;;;; Now an Example:;;;;;;   The famous Celsius-to-Fahrenheit relationship;;;;;;   C = 5 * (F - 32) / 9   ;;;   F = (9/5) * C + 32;;; ;;; BOTH conversion equations shouldn't need to exist.  Instead, consider;;; the following constraint relationship and corresponding network:;;;   ;;;    9 * C = 5 * (F - 32);;;           ___________              ____________     v    __________;;;   C -----| m1        |      u     |         m1 |--------| a1       |;;;          |     *   p |------------| p   *      |        |     +  s |------- F;;;      ----| m2        |            |         m2 |--    --| a2       |;;;     |    |___________|            |____________|  |   | |__________|;;;     |                                             |   |;;;  w  |                                           x |   | y;;;     |    ___                               ___    |   |    ____;;;     |   |   |                             |   |   |   |   |    |;;;      ---| 9 |                             | 5 |---     ---| 32 |;;;         |___|                             |___|           |____|;;;;;;----------------------------------------------------------------------------------(defmethod celsius-fahrenheit ((c kaleidostate) (f kaleidostate)                               &key state-types)  (let ((u (make-kaleidostate))        (v (make-kaleidostate))        (w (make-kaleidostate))        (x (make-kaleidostate))        (y (make-kaleidostate))        connector-s-t        c-s-t f-s-t)    (cond     ((listp state-types)      (setf c-s-t (first state-types))      (setf f-s-t (second state-types))      (setf connector-s-t (third state-types)))     (state-types      (setf c-s-t state-types)      (setf f-s-t state-types)      (setf connector-s-t state-types))     (T      (setf c-s-t NIL)      (setf f-s-t NIL)      (setf connector-s-t NIL))     )    (multiplier c w u           :state-types (list c-s-t connector-s-t connector-s-t))    (multiplier x v u :state-types connector-s-t)    (adder v y f           :state-types (list connector-s-t connector-s-t f-s-t))    (constant w 9.0 :state-type connector-s-t)    (constant x 5.0 :state-type connector-s-t)    (constant y 32.0 :state-type connector-s-t)    'Done))    